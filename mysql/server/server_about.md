# about

* mysql 服务器层不管理事务，事务由储存引擎实现。如果在一个事务中混用事务型与非事务型储存引擎时，正常提交没问题；回滚时，非事务型储存引擎会无法回滚。

## Mysql 如何执行查询

![查询执行流程](../images/query.png)

1. 客户端发送查询给服务器；
2. 服务器先检查查询缓存，如命中直接返回储存结果。否则，进入下一阶段；
3. 服务器进行SQL解析、预处理，再由优化器生成执行计划；
4. Mysql根据执行计划，调用储存引擎API来执行查询；
5. 将结果返回给客户端。

### Mysql 客户端/服务器通信协议

Mysql客户端与服务器之间的通信协议是“半双工”的。这意味着，在任意时刻，只能从客户端发送数据到服务器，或者从服务器发送数据到客户端，不可能同时进行。我们无法也无需将消息切成小块独立发送。

这种协议让Mysql通信简单快速，但也限制了Mysql。一旦一端开始发送消息，另一端要接收完整个消息才能响应。

客户端使用单独的数据包将查询发送给服务器。当查询语句很长，超过 max_allowed_packet 时，服务器会拒绝继续接收消息，并报错。一旦客户端发送的请求，它就只能等待了。

### 查询状态


**Sleep**
<br>&emsp;&emsp;线程正在等待客户端发送新请求。

**Query**
<br>&emsp;&emsp;线程正在执行查询或正在将结果发送给客户端。

**Locked**
<br>&emsp;&emsp;在Mysql服务器层，该线程正在等待表锁。在储存引擎级别实现的锁，例如InnoDB的行锁，不会体现在线程状态中。

**Analyzing and statistics**
<br>&emsp;&emsp;线程正在收集储存引擎统计信息，并生成执行计划。

**Copying to tmp table [on disc]**
<br>&emsp;&emsp;线程正在执行查询，并将结果复制到一个临时表中，这种状态一般要么在做 GROUP BY，要么是在文件排序，或者是UNION操作。如果这个状态后面还有 "on disk" 标记，那表锁Mysql正在将一个内存临时表放到磁盘上。

**Sorting result**
<br>&emsp;&emsp;线程正在对结果进行排序。

**Sending data**
<br>&emsp;&emsp;这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。
